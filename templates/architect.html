{% extends "base.html" %}

{% block content %}
<div class="architect-container">
    <div class="architect-form-container">
        <form method="POST" action="/architect" class="architect-input-form">
            <!-- Other form groups -->
            <div class="architect-form-group">
                <label for="show_tower">Show WTG</label>
                <input type="checkbox" id="show_tower" name="show_tower" {% if defaults.show_tower %}checked{% endif %} onchange="toggleTowerInputs()">

                <div class="architect-units-container">
                    <div class="architect-star-circle" onclick="showMessage()">â˜…</div>
                    <span id="architect-units-message" class="architect-units-message">! Units: N, mm, degrees !</span>
                </div>

            </div>
            <div class="architect-form-group">
                <label for="rna_cog">RNA CoG</label>
                <input type="text" id="rna_cog" name="rna_cog" value="{{ defaults.rna_cog }}">
            </div>
            <div class="architect-form-group">
                <label for="moment_interface_del">Moment interface</label>
                <input type="text" id="moment_interface_del" name="moment_interface_del" value="{{ defaults.moment_interface_del }}">
            </div>
            <div class="architect-form-group">
                <label for="shear_interface_del">Shear interface</label>
                <input type="text" id="shear_interface_del" name="shear_interface_del" value="{{ defaults.shear_interface_del }}">
            </div>
            <div class="architect-form-group">
                <label for="interface_elev">Interface elevation</label>
                <input type="text" id="interface_elev" name="interface_elev" value="{{ defaults.interface_elev }}">
            </div>
            <div class="architect-form-group">
                <label for="water_depth">Water depth (rel LAT)</label>
                <input type="text" id="water_depth" name="water_depth" value="{{ defaults.water_depth }}">
            </div>
            <div class="architect-form-group">
                <label for="msl">MSL</label>
                <input type="text" id="msl" name="msl" value="{{ defaults.msl }}">
            </div>
            <div class="architect-form-group">
                <label for="splash_lower">SZ lower</label>
                <input type="text" id="splash_lower" name="splash_lower" value="{{ defaults.splash_lower }}">
            </div>
            <div class="architect-form-group">
                <label for="splash_upper">SZ upper</label>
                <input type="text" id="splash_upper" name="splash_upper" value="{{ defaults.splash_upper }}">
            </div>
            <div class="architect-form-group">
                <label for="tp_btm">TP bottom</label>
                <input type="text" id="tp_btm" name="tp_btm" value="{{ defaults.tp_btm }}">
            </div>
            <div class="architect-form-group">
                <label for="tp_width">TP width</label>
                <input type="text" id="tp_width" name="tp_width" value="{{ defaults.tp_width }}">
            </div>
            <div class="architect-form-group">
                <label for="jacket_footprint">Jacket footprint</label>
                <input type="text" id="jacket_footprint" name="jacket_footprint" value="{{ defaults.jacket_footprint }}">
                <input type="range" id="jacket_footprint_slider" min="{{ jacket_footprint_min }}" max="{{ jacket_footprint_max }}" step="{{ jacket_footprint_step }}" value="{{ defaults.jacket_footprint }}">
            </div>
            <div class="architect-form-group">
                <label for="stickup">Stickup</label>
                <input type="text" id="stickup" name="stickup" value="{{ defaults.stickup }}">
                <input type="range" id="stickup_slider" min="{{ stickup_min }}" max="{{ stickup_max }}" step = "{{ stickup_step }}" value="{{ defaults.stickup }}">
            </div>
            <div class="architect-form-group">
                <label for="tp_btm_k1_voffset">k1 voffset from TP</label>
                <input type="text" id="tp_btm_k1_voffset" name="tp_btm_k1_voffset" value="{{ defaults.tp_btm_k1_voffset }}">
            </div>
            <div class="architect-form-group">
                <label for="btm_vert_leg_length">Vleg length bottom</label>
                <input type="text" id="btm_vert_leg_length" name="btm_vert_leg_length" value="{{ defaults.btm_vert_leg_length }}">
            </div>
            <div class="architect-form-group">
                <label for="n_bays">No. bays</label>
                <input type="text" id="n_bays" name="n_bays" value="{{ defaults.n_bays }}" oninput="generateBayInputs(); updatePlot();">
            </div>
            <div id="bay_heights_container" class="architect-form-group">
                <!-- Bay heights inputs will be generated here -->
            </div>
            <div class="architect-form-group">
                <label for="single_batter">Single batter</label>
                <input type="checkbox" id="single_batter" name="single_batter" {% if defaults.single_batter %}checked{% endif %} onchange="toggleBatterInputs()">
            </div>
            <div class="architect-form-group">
                <label for="batter_1_theta">Batter 1 Theta</label>
                <input type="text" id="batter_1_theta" name="batter_1_theta" value="{{ defaults.batter_1_theta }}">
                <input type="range" id="batter_1_theta_slider" min="{{ batter_1_theta_min }}" max="{{ batter_1_theta_max }}" value="{{ defaults.batter_1_theta }}">
            </div>
            <div class="architect-form-group">
                <label for="batter_1_elev">Batter 1 Elevation</label>
                <input type="text" id="batter_1_elev" name="batter_1_elev" value="{{ defaults.batter_1_elev }}">
                <input type="range" id="batter_1_elev_slider" min="{{ batter_1_elev_min }}" max="{{ batter_1_elev_max }}" value="{{ defaults.batter_1_elev }}">
            </div>
            <div class="architect-form-group">
                <label for="batter_2_theta">Batter 2 Theta</label>
                <input type="text" id="batter_2_theta" name="batter_2_theta" value="{{ batter_2_theta }}" disabled>
            </div>
        </form>
    </div>
    <div class="architect-plot-container">
        <div id="plot"></div>
    </div>
</div>

<div class="architect-export-button-container">
    <button type="button" onclick="exportFormData()">OPTIF export</button>
</div>


<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>

const debounce = (func, delay = 300) => {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
    };
};

function syncAndTrigger(id, callback) {
    const textInput = document.getElementById(id);
    const slider = document.getElementById(`${id}_slider`);

    if (textInput) {
        textInput.addEventListener('input', debounce(() => {
            if (slider) slider.value = textInput.value;
            callback();
        }));
    }

    if (slider) {
        slider.addEventListener('input', debounce(() => {
            if (textInput) textInput.value = slider.value;
            callback();
        }));
    }
}

document.querySelectorAll('.architect-input-form input').forEach(input => {
    input.addEventListener('input', debounce(function() {

        fetchBatter2Theta();
        fetchBatterElevationLimits();
        fetchStickUpLimits();
        fetchSingleBatterData();
        checkBatter2Theta();
        updatePlot();
    }));
});

document.querySelectorAll('.architect-input-form input[type="range"]').forEach(slider => {
    slider.addEventListener('input', debounce(function() {
        const correspondingInput = document.getElementById(this.id.replace('_slider', ''));
        if (correspondingInput) {
            correspondingInput.value = this.value;
        }

        fetchBatter2Theta();
        fetchBatterElevationLimits();
        fetchStickUpLimits();
        fetchSingleBatterData();
        updatePlot();
    }));
});

document.querySelectorAll('.architect-input-form input[type="text"]').forEach(textInput => {
    textInput.addEventListener('input', debounce(function() {
        const correspondingSlider = document.getElementById(this.id + '_slider');
        if (correspondingSlider) {
            correspondingSlider.value = this.value;
        }

        fetchBatter2Theta();
        fetchBatterElevationLimits();
        fetchStickUpLimits();
        fetchSingleBatterData();
        updatePlot();
    }));
});

['tp_btm', 'tp_btm_k1_voffset', 'water_depth', 'stickup', 'stickup_slider', 'n_bays'].forEach(id => {
    const input = document.getElementById(id);
    if (input) {
        input.addEventListener('input', debounce(() => {
            generateBayInputs();
            fetchBatter2Theta();
            fetchBatterElevationLimits();
            fetchStickUpLimits();
            updatePlot();
        }));
    }
});

window.addEventListener('resize', debounce(function() {
    Plotly.Plots.resize('plot');
}));

// Generate initial bay inputs based on default n_bays value
generateBayInputs();
updatePlot(); // Initial plot update with default values

function toggleTowerInputs() {
    var showTower = document.getElementById('show_tower').checked;
    document.getElementById('rna_cog').disabled = !showTower;
    document.getElementById('moment_interface_del').disabled = !showTower;
    document.getElementById('shear_interface_del').disabled = !showTower;
    updatePlot();
}

function updatePlot() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        const plotJson = JSON.parse(data.plot_json);
        plotJson.layout = plotJson.layout || {};
        plotJson.layout.autosize = true;
        plotJson.layout.margin = { l: 0, r: 0, t: 0, b: 0 };
        Plotly.newPlot('plot', plotJson.data, plotJson.layout, {responsive: true});
    })
    .catch(error => console.error('Error:', error));
}

function fetchBatter2Theta() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.batter_2_theta !== undefined) {
            const batter2Input = document.getElementById('batter_2_theta');
            batter2Input.value = data.batter_2_theta.toFixed(3);
            checkBatter2Theta(batter2Input);
        }
    })

    .catch(error => console.error('Error fetching batter_2_theta:', error));
}

function fetchBatterElevationLimits() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.batter_1_elev_min !== undefined) {
            document.getElementById('batter_1_elev_slider').min = data.batter_1_elev_min;
        }
        if (data.batter_1_elev_max !== undefined) {
            document.getElementById('batter_1_elev_slider').max = data.batter_1_elev_max;
        }
    })
    .catch(error => console.error('Error fetching batter elevations:', error));
}

function fetchStickUpLimits() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.stickup_min !== undefined) {
            document.getElementById('stickup_slider').min = data.stickup_min;
        }
        if (data.stickup_max !== undefined) {
            document.getElementById('stickup_slider').max = data.stickup_max;
        }
    })
    .catch(error => console.error('Error fetching stickup limits:', error));
}

function fetchSingleBatterData() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.batter_1_theta !== undefined) {
            const batter1Input = document.getElementById('batter_1_theta');
            batter1Input.value = data.batter_1_theta.toFixed(3);
        }
    })
    .catch(error => console.error('Error fetching batter_1_theta:', error));
}

function generateBayInputs() {
    const nBays = document.getElementById('n_bays').value;
    const container = document.getElementById('bay_heights_container');
    container.innerHTML = '';

    const tp_btm = parseFloat(document.getElementById('tp_btm').value);
    const tp_btm_k1_voffset = parseFloat(document.getElementById('tp_btm_k1_voffset').value);
    const water_depth = parseFloat(document.getElementById('water_depth').value);
    const stickup = parseFloat(document.getElementById('stickup').value);
    const jacket_height = ((tp_btm - tp_btm_k1_voffset) - (-water_depth + stickup));
    const equal_bay_height = jacket_height / nBays;
    const bayHeightValue = Math.floor(equal_bay_height);

    for (let i = 1; i <= nBays; i++) {
        const div = document.createElement('div');
        div.className = 'architect-form-group';
        const label = document.createElement('label');
        label.setAttribute('for', `bay_height_${i}`);
        label.textContent = `Bay ${i} height`;

        const input = document.createElement('input');
        input.type = 'text';
        input.id = `bay_height_${i}`;
        input.name = `bay_height_${i}`;
        input.value = bayHeightValue.toFixed(1);

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.id = `bay_height_${i}_slider`;
        slider.min = 100;
        slider.max = jacket_height / 2;
        slider.step = 100;
        slider.value = bayHeightValue.toFixed(1);

        slider.addEventListener('input', debounce(() => {
            input.value = slider.value;
            updatePlot();
            checkBayHeightsVsJacket();
        }));

        input.addEventListener('input', debounce(() => {
            slider.value = input.value;
            updatePlot();
            checkBayHeightsVsJacket();
        }));


        div.appendChild(label);
        div.appendChild(input);
        div.appendChild(slider);
        container.appendChild(div);
    }
    checkBayHeightsVsJacket();
}

function toggleBatterInputs() {
    var mbool = !document.getElementById('single_batter').checked;
    document.getElementById('batter_1_theta').disabled = !mbool;
    document.getElementById('batter_1_elev').disabled = !mbool;
    fetchSingleBatterData();
}

function exportFormData() {
    const formElements = document.querySelectorAll('.architect-form-container input, .architect-form-container select');
    let formData = {};
    formElements.forEach(el => {
        formData[el.name || el.id] = el.type === 'checkbox' ? el.checked : el.value;
    });

    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(formData, null, 2));
    const downloadAnchor = document.createElement('a');
    downloadAnchor.setAttribute("href", dataStr);
    downloadAnchor.setAttribute("download", "form_data.json");
    document.body.appendChild(downloadAnchor);
    downloadAnchor.click();
    downloadAnchor.remove();
}

function checkBayHeightsVsJacket() {
    const nBays = parseInt(document.getElementById('n_bays').value);
    let sum = 0;
    for (let i = 1; i <= nBays; i++) {
        const h = parseFloat(document.getElementById(`bay_height_${i}`).value);
        sum += h;
    }

    const tp_btm = parseFloat(document.getElementById('tp_btm').value);
    const tp_btm_k1_voffset = parseFloat(document.getElementById('tp_btm_k1_voffset').value);
    const water_depth = parseFloat(document.getElementById('water_depth').value);
    const stickup = parseFloat(document.getElementById('stickup').value);
    const jacket_height = ((tp_btm - tp_btm_k1_voffset) - (-water_depth + stickup));

    const exMarkId = 'bay-warning';
    const existing = document.getElementById(exMarkId);
    if (existing) existing.remove();

    if (sum > jacket_height) {
        const warning = document.createElement('span');
        warning.id = exMarkId;
        warning.textContent = '!';
        warning.style.display = 'inline-block';
        warning.style.width = '20px';
        warning.style.height = '20px';
        warning.style.lineHeight = '20px';
        warning.style.borderRadius = '50%';
        warning.style.backgroundColor = 'red';
        warning.style.color = 'white';
        warning.style.textAlign = 'center';
        warning.style.fontWeight = 'bold';
        warning.style.marginLeft = '8px';
        warning.style.cursor = 'pointer';
        warning.addEventListener('click', () => {
            alert("Bay height inputs exceed jacket height! Reduce some of the bay heights to continue...! \
            \nBraces are allowed to span between the 'k1voffset from TP' to the top of pile stickup.\
            \nReduce the bay heights to continue your design.");
        });

        const target = document.getElementById('n_bays');
        target.parentNode.insertBefore(warning, target.nextSibling);
    }

}

function checkBatter2Theta(batter2Input) {
    // If batter2Input is an input element, we retrieve the value
    const value = batter2Input ? parseFloat(batter2Input.value) : parseFloat(batter2Input);

    if (isNaN(value) || value < 0) {
        let existingWarning = document.getElementById('batter_2_theta_warning');
        if (!existingWarning) {
            const warning = document.createElement('span');
            warning.id = 'batter_2_theta_warning';
            warning.textContent = '!';
            warning.style.display = 'inline-block';
            warning.style.width = '20px';
            warning.style.height = '20px';
            warning.style.lineHeight = '20px';
            warning.style.borderRadius = '50%';
            warning.style.backgroundColor = 'red';
            warning.style.color = 'white';
            warning.style.textAlign = 'center';
            warning.style.fontWeight = 'bold';
            warning.style.marginLeft = '8px';
            warning.style.cursor = 'pointer';

            warning.addEventListener('click', () => {
                alert("Warning: Negative Batter 2 angle encountered!");
            });

            batter2Input?.parentNode.appendChild(warning);  // append warning to input's parent if it's an element
        }
    } else {
        let existingWarning = document.getElementById('batter_2_theta_warning');
        if (existingWarning) {
            existingWarning.remove();
        }
    }
}

function showMessage() {
    const message = document.getElementById('architect-units-message');
    message.style.display = message.style.display === 'none' ? 'inline' : 'none';
}

</script>


{% endblock %}
