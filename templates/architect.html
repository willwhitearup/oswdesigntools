{% extends "base.html" %}

{% block content %}
<div class="architect-container">
    <div class="architect-form-container">
        <form method="POST" action="/architect" class="architect-input-form">
            <!-- Other form groups -->
            <div class="architect-form-group">
                <label for="show_tower">Show WTG</label>
                <input type="checkbox" id="show_tower" name="show_tower" {% if defaults.show_tower %}checked{% endif %} onchange="toggleTowerInputs()">

                <div class="architect-units-container">
                    <div class="architect-info-circle" onclick="showMessage()">i</div>
                    <span id="architect-units-message" class="architect-units-message">! Units: N, mm, degrees !</span>
                </div>

            </div>
            <div class="architect-form-group">
                <label for="rna_cog">RNA CoG</label>
                <input type="text" id="rna_cog" name="rna_cog" value="{{ defaults.rna_cog }}">
            </div>
            <div class="architect-form-group">
                <label for="moment_interface_del">Moment interface</label>
                <input type="text" id="moment_interface_del" name="moment_interface_del" value="{{ defaults.moment_interface_del }}">
            </div>
            <div class="architect-form-group">
                <label for="shear_interface_del">Shear interface</label>
                <input type="text" id="shear_interface_del" name="shear_interface_del" value="{{ defaults.shear_interface_del }}">
            </div>
            <div class="architect-form-group">
                <label for="interface_elev">Interface elevation</label>
                <input type="text" id="interface_elev" name="interface_elev" value="{{ defaults.interface_elev }}">
            </div>
            <div class="architect-form-group">
                <label for="water_depth">Water depth (rel LAT)</label>
                <input type="text" id="water_depth" name="water_depth" value="{{ defaults.water_depth }}">
            </div>
            <div class="architect-form-group">
                <label for="msl">MSL</label>
                <input type="text" id="msl" name="msl" value="{{ defaults.msl }}">
            </div>
            <div class="architect-form-group">
                <label for="splash_lower">SZ lower</label>
                <input type="text" id="splash_lower" name="splash_lower" value="{{ defaults.splash_lower }}">
            </div>
            <div class="architect-form-group">
                <label for="splash_upper">SZ upper</label>
                <input type="text" id="splash_upper" name="splash_upper" value="{{ defaults.splash_upper }}">
            </div>
            <div class="architect-form-group">
                <label for="tp_btm">TP bottom</label>
                <input type="text" id="tp_btm" name="tp_btm" value="{{ defaults.tp_btm }}">
            </div>
            <div class="architect-form-group">
                <label for="tp_width">TP width</label>
                <input type="text" id="tp_width" name="tp_width" value="{{ defaults.tp_width }}">
            </div>
            <div class="architect-form-group">
                <label for="jacket_footprint">Jacket footprint</label>
                <input type="text" id="jacket_footprint" name="jacket_footprint" value="{{ defaults.jacket_footprint }}">
                <input type="range" id="jacket_footprint_slider" min="{{ jacket_footprint_min }}" max="{{ jacket_footprint_max }}" step="{{ jacket_footprint_step }}" value="{{ defaults.jacket_footprint }}">
            </div>
            <div class="architect-form-group">
                <label for="stickup">Stickup</label>
                <input type="text" id="stickup" name="stickup" value="{{ defaults.stickup }}">
                <input type="range" id="stickup_slider" min="{{ stickup_min }}" max="{{ stickup_max }}" step = "{{ stickup_step }}" value="{{ defaults.stickup }}">
            </div>
            <div class="architect-form-group">
                <label for="tp_btm_k1_voffset">k1 voffset from TP</label>
                <input type="text" id="tp_btm_k1_voffset" name="tp_btm_k1_voffset" value="{{ defaults.tp_btm_k1_voffset }}">
            </div>
            <div class="architect-form-group">
                <label for="btm_vert_leg_length">Vleg length bottom</label>
                <input type="text" id="btm_vert_leg_length" name="btm_vert_leg_length" value="{{ defaults.btm_vert_leg_length }}">
            </div>


            <div class="architect-form-group" style="display: flex; justify-content: space-between; align-items: center;">
                <div style="flex-grow: 1;">
                    <label for="n_bays">No. bays</label>
                    <input type="text" id="n_bays" name="n_bays" value="{{ defaults.n_bays }}" oninput="generateBayInputs(); updatePlot();" style="margin-left: 32px;">
                </div>
                <div style="position: relative; white-space: nowrap;">
                    bay horizontal
                    <div style="position: absolute; top: 100%; left: 90%; transform: translateX(-50%); width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 10px solid black;"></div>
                </div>
            </div>



            <div id="bay_heights_container" class="architect-form-group">
                <!-- Bay heights inputs will be generated here -->
            </div>


            <div id="bay-inputs-container">
                <!-- Bay horizontals inputs will be generated here -->
            </div>
            <div class="architect-form-group">
                <label for="single_batter">Single batter</label>
                <input type="checkbox" id="single_batter" name="single_batter" {% if defaults.single_batter %}checked{% endif %} onchange="toggleBatterInputs()">
            </div>
            <div class="architect-form-group">
                <label for="batter_1_theta">Batter 1 Theta</label>
                <input type="text" id="batter_1_theta" name="batter_1_theta" value="{{ defaults.batter_1_theta }}">
                <input type="range" id="batter_1_theta_slider" min="{{ batter_1_theta_min }}" max="{{ batter_1_theta_max }}" value="{{ defaults.batter_1_theta }}">
            </div>
            <div class="architect-form-group">
                <label for="batter_1_elev">Batter 1 Elevation</label>
                <input type="text" id="batter_1_elev" name="batter_1_elev" value="{{ defaults.batter_1_elev }}">
                <input type="range" id="batter_1_elev_slider" min="{{ batter_1_elev_min }}" max="{{ batter_1_elev_max }}" value="{{ defaults.batter_1_elev }}">
            </div>
            <div class="architect-form-group">
                <label for="batter_2_theta">Batter 2 Theta</label>
                <input type="text" id="batter_2_theta" name="batter_2_theta" value="{{ batter_2_theta }}" disabled>
            </div>
        </form>
    </div>
    <div class="architect-plot-container">
        <div id="plot"></div>
    </div>
</div>

<div class="architect-export-button-container">
    <button type="button" onclick="exportFormData()">OPTIF export</button>
</div>


<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>

const debounce = (func, delay = 300) => {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), delay);
    };
};

function syncAndTrigger(id, callback) {
    const textInput = document.getElementById(id);
    const slider = document.getElementById(`${id}_slider`);

    if (textInput) {
        textInput.addEventListener('input', debounce(() => {
            if (slider) slider.value = textInput.value;
            callback();
        }));
    }

    if (slider) {
        slider.addEventListener('input', debounce(() => {
            if (textInput) textInput.value = slider.value;
            callback();
        }));
    }
}

document.querySelectorAll('.architect-input-form input').forEach(input => {
    input.addEventListener('input', debounce(function() {


        InterfaceElevationValidity()
        fetchBatter2Theta();
        fetchBatterElevationLimits();
        fetchStickUpLimits();
        fetchSingleBatterData();
        checkBatter2Theta();
        updatePlot();
    }));
});

document.querySelectorAll('.architect-input-form input[type="range"]').forEach(slider => {
    slider.addEventListener('input', debounce(function() {
        const correspondingInput = document.getElementById(this.id.replace('_slider', ''));
        if (correspondingInput) {
            correspondingInput.value = this.value;
        }

        InterfaceElevationValidity()
        fetchBatter2Theta();
        fetchBatterElevationLimits();
        fetchStickUpLimits();
        fetchSingleBatterData();
        updatePlot();
    }));
});

document.querySelectorAll('.architect-input-form input[type="text"]').forEach(textInput => {
    textInput.addEventListener('input', debounce(function() {
        const correspondingSlider = document.getElementById(this.id + '_slider');
        if (correspondingSlider) {
            correspondingSlider.value = this.value;
        }

        InterfaceElevationValidity()
        fetchBatter2Theta();
        fetchBatterElevationLimits();
        fetchStickUpLimits();
        fetchSingleBatterData();
        updatePlot();
    }));
});

['tp_btm', 'tp_btm_k1_voffset', 'water_depth', 'stickup', 'stickup_slider', 'n_bays'].forEach(id => {
    const input = document.getElementById(id);
    if (input) {
        input.addEventListener('input', debounce(() => {

            InterfaceElevationValidity()
            generateBayInputs();
            fetchBatter2Theta();
            fetchBatterElevationLimits();
            fetchStickUpLimits();
            updatePlot();
        }));
    }
});

window.addEventListener('resize', debounce(function() {
    Plotly.Plots.resize('plot');
}));

// Generate initial bay inputs based on default n_bays value
generateBayInputs();
updatePlot(); // Initial plot update with default values

function toggleTowerInputs() {
    var showTower = document.getElementById('show_tower').checked;
    document.getElementById('rna_cog').disabled = !showTower;
    document.getElementById('moment_interface_del').disabled = !showTower;
    document.getElementById('shear_interface_del').disabled = !showTower;
    updatePlot();
}

function updatePlot() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        const plotJson = JSON.parse(data.plot_json);
        plotJson.layout = plotJson.layout || {};
        plotJson.layout.autosize = true;
        plotJson.layout.margin = { l: 0, r: 0, t: 0, b: 0 };
        Plotly.newPlot('plot', plotJson.data, plotJson.layout, {responsive: true});
    })
    .catch(error => console.error('Error:', error));
}

function fetchBatter2Theta() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.batter_2_theta !== undefined) {
            const batter2Input = document.getElementById('batter_2_theta');
            batter2Input.value = data.batter_2_theta.toFixed(3);
            checkBatter2Theta(batter2Input);
        }
    })

    .catch(error => console.error('Error fetching batter_2_theta:', error));
}

function fetchBatterElevationLimits() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.batter_1_elev_min !== undefined) {
            document.getElementById('batter_1_elev_slider').min = data.batter_1_elev_min;
        }
        if (data.batter_1_elev_max !== undefined) {
            document.getElementById('batter_1_elev_slider').max = data.batter_1_elev_max;
        }
    })
    .catch(error => console.error('Error fetching batter elevations:', error));
}

function fetchStickUpLimits() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.stickup_min !== undefined) {
            document.getElementById('stickup_slider').min = data.stickup_min;
        }
        if (data.stickup_max !== undefined) {
            document.getElementById('stickup_slider').max = data.stickup_max;
        }
    })
    .catch(error => console.error('Error fetching stickup limits:', error));
}

function fetchSingleBatterData() {
    const formData = new FormData(document.querySelector('.architect-input-form'));
    fetch('/architect', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.batter_1_theta !== undefined) {
            const batter1Input = document.getElementById('batter_1_theta');
            batter1Input.value = data.batter_1_theta.toFixed(3);
        }
    })
    .catch(error => console.error('Error fetching batter_1_theta:', error));
}









function generateBayInputs() {
    const nBays = document.getElementById('n_bays').value;
    const container = document.getElementById('bay_heights_container');
    container.innerHTML = '';

    const tp_btm = parseFloat(document.getElementById('tp_btm').value);
    const tp_btm_k1_voffset = parseFloat(document.getElementById('tp_btm_k1_voffset').value);
    const water_depth = parseFloat(document.getElementById('water_depth').value);
    const stickup = parseFloat(document.getElementById('stickup').value);
    const jacket_height = ((tp_btm - tp_btm_k1_voffset) - (-water_depth + stickup));
    const equal_bay_height = jacket_height / nBays;
    const bayHeightValue = Math.floor(equal_bay_height);

    // Array to store checkbox states
    const bayHorizontalStates = [];

    for (let i = 1; i <= nBays; i++) {
        const div = document.createElement('div');
        div.className = 'architect-form-group';

        const label = document.createElement('label');
        label.setAttribute('for', `bay_height_${i}`);
        label.textContent = `Bay ${i} height`;

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `bay_horizontal_${i}`;
        checkbox.name = `bay_horizontal_${i}`;
        checkbox.value = 'on';

        // Store checkbox state in array
        bayHorizontalStates.push(checkbox.checked);

        const input = document.createElement('input');
        input.type = 'text';
        input.id = `bay_height_${i}`;
        input.name = `bay_height_${i}`;
        input.value = bayHeightValue.toFixed(1);

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.id = `bay_height_${i}_slider`;
        slider.min = 100;
        slider.max = jacket_height / 2;
        slider.step = 100;
        slider.value = bayHeightValue.toFixed(1);

        // Append elements in the desired order: label, input, checkbox, and slider
        div.appendChild(label);
        div.appendChild(input);
        div.appendChild(slider);
        div.appendChild(checkbox);

        // Adding event listeners to sync input and slider
        slider.addEventListener('input', debounce(() => {
            input.value = slider.value;
            updatePlot();
            checkBayHeightsVsJacket();
        }));

        input.addEventListener('input', debounce(() => {
            slider.value = input.value;
            updatePlot();
            checkBayHeightsVsJacket();
        }));

        // Add checkbox listener
        checkbox.addEventListener('change', () => {
            updatePlot(); // or any other relevant function
        });

        // Appending the div to the container
        container.appendChild(div);

        console.log(`Bay ${i} horizontal:`, checkbox.checked);
    }

    // Function to retrieve checkbox states
    function getBayHorizontalStates() {
        return bayHorizontalStates;
    }

    checkBayHeightsVsJacket();
}









function toggleBatterInputs() {
    var mbool = !document.getElementById('single_batter').checked;
    document.getElementById('batter_1_theta').disabled = !mbool;
    document.getElementById('batter_1_elev').disabled = !mbool;
    fetchSingleBatterData();
}

function exportFormData() {
    const formElements = document.querySelectorAll('.architect-form-container input, .architect-form-container select');
    let formData = {};
    formElements.forEach(el => {
        formData[el.name || el.id] = el.type === 'checkbox' ? el.checked : el.value;
    });

    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(formData, null, 2));
    const downloadAnchor = document.createElement('a');
    downloadAnchor.setAttribute("href", dataStr);
    downloadAnchor.setAttribute("download", "form_data.json");
    document.body.appendChild(downloadAnchor);
    downloadAnchor.click();
    downloadAnchor.remove();
}

function checkBayHeightsVsJacket() {
    const nBays = parseInt(document.getElementById('n_bays').value);
    let sum = 0;
    for (let i = 1; i <= nBays; i++) {
        const h = parseFloat(document.getElementById(`bay_height_${i}`).value);
        sum += h;
    }

    const tp_btm = parseFloat(document.getElementById('tp_btm').value);
    const tp_btm_k1_voffset = parseFloat(document.getElementById('tp_btm_k1_voffset').value);
    const water_depth = parseFloat(document.getElementById('water_depth').value);
    const stickup = parseFloat(document.getElementById('stickup').value);
    const jacket_height = ((tp_btm - tp_btm_k1_voffset) - (-water_depth + stickup));

    const exMarkId = 'bay-warning';
    const existing = document.getElementById(exMarkId);
    if (existing) existing.remove();

    if (sum > jacket_height) {
        const warning = document.createElement('span');
        warning.id = exMarkId;
        warning.textContent = '!';

        // css styling
        warning.style.position = 'absolute';
        warning.style.top = '50%';  // Vertically center it
        warning.style.left = '50%';  // Horizontally center it
        warning.style.transform = 'translate(-50%, -50%)';  // Offset to truly center it
        warning.style.width = '30px';
        warning.style.height = '30px';
        warning.style.lineHeight = '30px';
        warning.style.borderRadius = '50%';
        warning.style.backgroundColor = 'red';
        warning.style.color = 'white';
        warning.style.textAlign = 'center';
        warning.style.fontWeight = 'bold';
        warning.style.fontSize = '28px';
        warning.style.zIndex = '10';  // Ensure it's on top of other content
        warning.style.cursor = 'pointer';

        // event listener
        warning.addEventListener('click', () => {
            alert("Bay height inputs exceed jacket height! Reduce some of the bay heights to continue...! \
            \nBraces are allowed to span between the 'k1voffset from TP' to the top of pile stickup.\
            \nReduce the bay heights to continue your design.");
        });

        const target = document.getElementById('bay_heights_container');
        target.style.position = 'relative';  // Make sure this container is relative to hold the absolute warning
        target.appendChild(warning);  // Append the warning to the container
    }

}

function checkBatter2Theta(batter2Input) {
    // If batter2Input is an input element, we retrieve the value
    const value = batter2Input ? parseFloat(batter2Input.value) : parseFloat(batter2Input);

    if (isNaN(value) || value < 0) {
        let existingWarning = document.getElementById('batter_2_theta_warning');
        if (!existingWarning) {
            const warning = document.createElement('span');
            warning.id = 'batter_2_theta_warning';
            warning.textContent = '!';
            warning.style.display = 'inline-block';
            warning.style.width = '20px';
            warning.style.height = '20px';
            warning.style.lineHeight = '20px';
            warning.style.borderRadius = '50%';
            warning.style.backgroundColor = 'orange';
            warning.style.color = 'white';
            warning.style.textAlign = 'center';
            warning.style.fontWeight = 'bold';
            warning.style.marginLeft = '8px';
            warning.style.cursor = 'pointer';

            warning.addEventListener('click', () => {
                alert("Warning: Negative Batter 2 angle encountered!");
            });

            batter2Input?.parentNode.appendChild(warning);  // append warning to input's parent if it's an element
        }
    } else {
        let existingWarning = document.getElementById('batter_2_theta_warning');
        if (existingWarning) {
            existingWarning.remove();
        }
    }
}

function InterfaceElevationValidity() {
    const tp_btm = parseFloat(document.getElementById('tp_btm').value);
    const interface_elev = parseFloat(document.getElementById('interface_elev').value);

    const warningId = 'interface-warning';  // ID for the warning element

    // Check if the warning already exists
    const existingWarning = document.getElementById(warningId);

    if (interface_elev < tp_btm) {
        // If warning does not exist, create it
        if (!existingWarning) {
            const warning = document.createElement('span');
            warning.id = warningId;  // Set the warning's id
            warning.textContent = '!';

            // CSS styling for the warning
            warning.style.display = 'inline-block';
            warning.style.width = '20px';
            warning.style.height = '20px';
            warning.style.lineHeight = '20px';
            warning.style.borderRadius = '50%';
            warning.style.backgroundColor = 'red';
            warning.style.color = 'white';
            warning.style.textAlign = 'center';
            warning.style.fontWeight = 'bold';
            warning.style.marginLeft = '8px';  // Space between input and warning
            warning.style.cursor = 'pointer';

            // Event listener for the warning
            warning.addEventListener('click', () => {
                alert("interface elev is below the bottom of the TP. \n\nUpdate design to continue!");
            });

            // Find the parent container and append the warning next to the input
            const target = document.querySelector('.architect-form-group');
            target.appendChild(warning);  // Append the warning to the container (next to input)
        }
    } else {
        // If the issue is fixed and the warning exists, remove it
        if (existingWarning) {
            existingWarning.remove();
        }
    }
}



function showMessage() {
    const message = document.getElementById('architect-units-message');
    const isHidden = window.getComputedStyle(message).display === 'none';
    message.style.display = isHidden ? 'inline' : 'none';
}


</script>


{% endblock %}
